{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyFactories","text":"<p> \ud83d\ude80 Mock data generation for pydantic and dataclasses. \ud83d\ude80 </p> <p> </p> <p>Documentation: https://pyfactories.tarsild.io \ud83d\udcda</p> <p>Source Code: https://github.com/dymmond/esmerald</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Pydantic Factories was initially created and used by a lot of people and it is an extremely powerful package that was heavily tested by the same authors of Starlite, now, Litestar. During their own evolution and development they felt the need to add more support to the package that was no longer only pydantic and therefore they created the Polyfactory and archived the Pydantic Factories.</p> <p>PyFactories is a literal fork from the latest Pydantic Factories and aims to continue the same work set by the previous creators with the difference that will be only maintaining the factories for Pydantic and the upcoming Pydantic 2.0+.</p> <p>The team behind Pydantic Factories did a fantastic job and the credit goes to them while PyFactories continues its own fork path.</p> <p>If you aim to use something more than just Pydantic, it is strongly recommended to visit Polyfactory and migrate to it and of course, leave them a \u2b50\ufe0f.</p> <p>In the meantime if you only want the Pydantic side of things, then you can use PyFactories in the same fashion as its ancestor.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyfactories\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>from datetime import date, datetime\nfrom typing import List, Union\n\nfrom pydantic import UUID4, BaseModel\n\nfrom pyfactories import ModelFactory\n\n\nclass Person(BaseModel):\n    id: UUID4\n    name: str\n    hobbies: List[str]\n    age: Union[float, int]\n    birthday: Union[datetime, date]\n\n\nclass PersonFactory(ModelFactory):\n    __model__ = Person\n\n\nresult = PersonFactory.build()\n</code></pre> <p>And just its own ancestor, this is it. Almost no work, you are able to create mock data objects that fits the <code>Person</code> Pydantic class model definition.</p> <p>This is possible because of the typing information available on the pydantic model and model-fields, which are used as a source of truth for data generation.</p> <p>The factory parses the information stored in the pydantic model and generates a dictionary of kwargs that are passed to the <code>Person</code> class' <code>init</code> method.</p>"},{"location":"#migrate-from-pydantic-factories","title":"Migrate from Pydantic Factories","text":"<p>It is actually straightforward, you simply need to replace <code>pydantic_factories</code> with <code>pyfactories</code> in your imports and that is it.</p>"},{"location":"#features","title":"Features","text":"<p>Being initially the fork of Pydantic Factories, that also means:</p> <ul> <li>\u2705 Supports both built-in and pydantic types</li> <li>\u2705 Supports pydantic field constraints</li> <li>\u2705 Supports complex field types</li> <li>\u2705 Supports custom model fields</li> <li>\u2705 Supports dataclasses</li> <li>\u2705 Supports TypedDicts</li> </ul>"},{"location":"#why-this-library","title":"Why This Library","text":"<p>This library was widely used before because of its powerfull features and therefore with the upcoming Pydantic 2.0, it will be even more robust with the core done in Rust.</p> <ul> <li>\ud83d\udcaf Powerful</li> <li>\ud83d\udcaf Extensible</li> <li>\ud83d\udcaf Simple</li> <li>\ud83d\udcaf Rigorously tested</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>This library is open to contributions. Please see the contribution guide!</p>"},{"location":"#star-the-initial-authors","title":"Star the initial authors","text":"<p>Although the intial Pydantic Factories is no longer maintained, there is always the Polyfactory that deserves a \u2b50\ufe0f.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for showing interes in contributing to PyFactories. There are many ways you can help and contribute to the project.</p> <ul> <li>Try PyFactories and report bugs and issues you find.</li> <li>Implement new features</li> <li>Help othes by reviewing pull requests</li> <li>Help writting documentation</li> <li>Use the discussions and actively participate on them.</li> <li>Become an contributor by helping PyFactories growing and spread the words across small, medium, large or any company size.</li> </ul>"},{"location":"contributing/#reporting-possible-bugs-and-issues","title":"Reporting possible bugs and issues","text":"<p>It is natural that you might find something that PyFactories should support or even experience some sorte of unexpected behaviour that needs addressing.</p> <p>The way we love doing things is very simple, contributions should start out with a discussion. The potential bugs shall be raised as \"Potential Issue\" in the discussions, the feature requests may be raised as \"Ideas\".</p> <p>We can then decide if the discussion needs to be escalated into an \"Issue\" or not.</p> <p>When reporting something you should always try to:</p> <ul> <li>Be as more descriptive as possible</li> <li>Provide as much evidence as you can, something like:<ul> <li>OS platform</li> <li>Python version</li> <li>Installed dependencies</li> <li>Code snippets</li> <li>Tracebacks</li> </ul> </li> </ul> <p>Avoid putting examples extremely complex to understand and read. Simplify the examples as much as possible to make it clear to understand and get the required help.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>To develop for PyFactories, create a fork of the PyFactories repository on GitHub.</p> <p>After, clone your fork with the follow command replacing <code>YOUR-USERNAME</code> wih your GitHub username:</p> <pre><code>$ git clone https://github.com/YOUR-USERNAME/pyfactories\n</code></pre>"},{"location":"contributing/#install-the-project-dependencies","title":"Install the project dependencies","text":"<pre><code>$ cd pyfactories\n$ scripts/install\n</code></pre>"},{"location":"contributing/#enable-pre-commit","title":"Enable pre-commit","text":"<p>The project comes with a pre-commit hook configuration. To enable it, just run inside the clone:</p> <pre><code>$ pre-commit\n</code></pre>"},{"location":"contributing/#run-the-tests","title":"Run the tests","text":"<p>To run the tests, use:</p> <pre><code>$ scripts/test\n</code></pre> <p>Because PyFactories uses pytest, any additional arguments will be passed. More info within the pytest documentation</p> <p>For example, to run a single test_script:</p> <pre><code>$ scripts/test tests/test_apiviews.py\n</code></pre> <p>To run the linting, use:</p> <pre><code>$ scripts/format\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Improving the documentation is quite easy and it is placed inside the <code>pyfactories/docs</code> folder.</p> <p>To start the docs, run:</p> <pre><code>$ scripts/docs\n</code></pre>"},{"location":"contributing/#building-pyfactories","title":"Building PyFactories","text":"<p>To build a package locally, run:</p> <pre><code>$ scripts/build\n</code></pre> <p>Alternatively running:</p> <pre><code>$ scripts/install\n</code></pre> <p>It will install the requirements and create a local build in your virtual environment.</p>"},{"location":"contributing/#releasing","title":"Releasing","text":"<p>This section is for the maintainers of <code>PyFactories</code>.</p>"},{"location":"contributing/#building-the-pyfactories-for-release","title":"Building the PyFactories for release","text":"<p>Before releasing a new package into production some considerations need to be taken into account.</p> <ul> <li> <p>Changelog</p> <ul> <li>Like many projects, we follow the format from keepchangelog.</li> <li>Compare <code>main</code> with the release tag and list of the entries that are of interest to the users of the framework.<ul> <li>What must go in the changelog? added, changed, removed or deprecated features and the bug fixes.</li> <li>What is should not go in the changelog? Documentation changes, tests or anything not specified in the point above.</li> <li>Make sure the order of the entries are sorted by importance.</li> <li>Keep it simple.</li> </ul> </li> </ul> </li> <li> <p>Version bump</p> <ul> <li>The version should be in <code>__init__.py</code> of the main package.</li> </ul> </li> </ul>"},{"location":"contributing/#releasing_1","title":"Releasing","text":"<p>Once the <code>release</code> PR is merged, create a new release that includes:</p> <p>Example:</p> <p>There will be a release of the version <code>0.2.3</code>, this is what it should include.</p> <ul> <li>Release title: <code>Version 0.2.3</code>.</li> <li>Tag: <code>0.2.3</code>.</li> <li>The description should be copied from the changelog.</li> </ul> <p>Once the release is created, it should automatically upload the new version to PyPI. If something does not work with PyPI the release can be done by running <code>scripts/release</code>.</p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#010","title":"0.1.0","text":"<ul> <li>Initial release of the fork from Pydantic Factories.</li> <li>Documentation updated.</li> </ul>"},{"location":"sponsorship/","title":"Help PyFactories","text":"<p>Do you like PyFactories and would like to help PyFactories, other user and the author?</p>"},{"location":"sponsorship/#star-pyfactories-on-github","title":"\u2b50 Star PyFactories on GitHub","text":"<p>Giving a star to PyFactories is very simple and helps promoting the work across the developers around the world.</p> <p>The button is located at the top right.</p> <p>https://github.com/tarsil/pyfactories.</p> <p>This will help spreading the word about the tool and how helpful has been.</p>"},{"location":"sponsorship/#star-polyfactory-on-github","title":"\u2b50 Star Polyfactory on GitHub","text":"<p>Giving a star to Polyfactory is very simple and helps promoting the work of the developers that originally created Pydantic Factories.</p> <p>The button is located at the top right.</p> <p>https://github.com/litestar-org/polyfactory.</p> <p>This will help spreading the word about the tool and how helpful has been.</p>"},{"location":"sponsorship/#follow-the-github-repo","title":"\ud83d\udc40 Follow the GitHub repo","text":"<p>Following the GitHub repo will allow you to \"watch\" for any new release of PyFactories and be always up to date.</p> <p>You can click on \"watch\" and select \"custom\" -&gt; \"Releases\"or any other you may find particular interesting to you.</p>"},{"location":"sponsorship/#sponsor-the-author","title":"\ud83d\udd25 Sponsor the author","text":"<p>The author built this framework with all of his heart and dedication and will continue to do it so but that also requires time and resources and when they are limited, the process still gets there but takes a bit longer.</p> <p>You can financially help and support the author though GitHub sponsors</p> <p>He can afterwards go for a coffee\u2615, on him, to say thanks\ud83d\ude4f.</p>"},{"location":"usage/build-methods/","title":"Build Methods","text":"<p>The <code>ModelFactory</code> class exposes two build methods:</p> <ul> <li><code>.build(**kwargs)</code> - builds a single instance of the factory's model</li> <li><code>.batch(size: int, **kwargs)</code> - build a list of size n instances</li> </ul> <pre><code>from pydantic import BaseModel\n\nfrom pyfactories import ModelFactory\n\n\nclass Person(BaseModel):\n    ...\n\n\nclass PersonFactory(ModelFactory):\n    __model__ = Person\n\n\nsingle_result = PersonFactory.build()  # a single Person instance\n\nbatch_result = PersonFactory.batch(size=5)  # list[Person, Person, Person, Person, Person]\n</code></pre> <p>Any <code>kwargs</code> you pass to <code>.build</code>, <code>.batch</code> or any of the persistence methods, will take precedence over whatever defaults are defined on the factory class itself.</p> <p>By default, when building a pydantic class, kwargs are validated, to avoid input validation you can use the <code>factory_use_construct</code> param.</p> <pre><code>from pydantic import BaseModel\n\nfrom pyfactories import ModelFactory\n\n\nclass Person(BaseModel):\n    ...\n\n\nclass PersonFactory(ModelFactory):\n    __model__ = Person\n\n\nPersonFactory.build(id=5)  # Raises a validation error\n\nresult = PersonFactory.build(factory_use_construct=True, id=5)  # Build a Person with invalid id\n</code></pre>"},{"location":"usage/build-methods/#partial-parameters","title":"Partial Parameters","text":"<p>Factories can randomly generate missing parameters for child factories. For example:</p> <pre><code>from pydantic import BaseModel\n\nfrom pyfactories import ModelFactory\n\n\nclass Pet(BaseModel):\n    name: str\n    age: int\n\n\nclass Person(BaseModel):\n    name: str\n    pets: list[Pet]\n    age: int\n\n\nclass PersonFactory(ModelFactory[Person]):\n    __model__ = Person\n</code></pre> <p>When building a person without specifying the Person and pets ages, all these fields will be randomly generated:</p> <pre><code>from pydantic import BaseModel\n\nfrom pyfactories import ModelFactory\n\n\nclass Pet(BaseModel):\n    name: str\n    age: int\n\n\nclass Person(BaseModel):\n    name: str\n    pets: list[Pet]\n    age: int\n\n\nclass PersonFactory(ModelFactory[Person]):\n    __model__ = Person\n\n\ndata = {\n    \"name\": \"John\",\n    \"pets\": [\n        {\"name\": \"dog\"},\n        {\"name\": \"cat\"},\n    ],\n}\n\nperson = PersonFactory.build(**data)\n\nprint(person.json(indent=2))\n</code></pre> <pre><code>{\n\"name\": \"John\",\n\"pets\": [\n{\n\"name\": \"dog\",\n\"age\": 9005\n},\n{\n\"name\": \"cat\",\n\"age\": 2455\n}\n],\n\"age\": 975\n}\n</code></pre>"},{"location":"usage/configuration/","title":"Factory Configuration","text":"<p>Configuration of <code>ModelFactory</code> is done using class variables:</p> <ul> <li> <p>__model__: a required variable specifying the model for the factory. It accepts any class that extends _   pydantic's_ <code>BaseModel</code> including classes from other libraries. If this variable is not set,   a <code>ConfigurationException</code> will be raised.</p> </li> <li> <p>__faker__: an optional variable specifying a user configured instance of faker. If this variable is not set,   the factory will default to using vanilla <code>faker</code>.</p> </li> <li> <p>__sync_persistence__: an optional variable specifying the handler for synchronously persisting data. If this   is variable is not set, the <code>.create_sync</code> and <code>.create_batch_sync</code> methods of the factory cannot be used.   See: persistence methods</p> </li> <li> <p>__async_persistence__: an optional variable specifying the handler for asynchronously persisting data. If   this is variable is not set, the <code>.create_async</code> and <code>.create_batch_async</code> methods of the factory cannot be used.   See: persistence methods</p> </li> <li> <p>__allow_none_optionals__: an optional variable specifying whether the factory should randomly set None   values for optional fields, or always set a value for them. This is <code>True</code> by default.</p> </li> </ul> <pre><code>from app.models import Person\nfrom faker import Faker\n\nfrom pyfactories import ModelFactory\n\nfrom .persistence import AsyncPersistenceHandler, SyncPersistenceHandler\n\nFaker.seed(5)\nmy_faker = Faker(\"en-EN\")\n\n\nclass PersonFactory(ModelFactory):\n    __model__ = Person\n    __faker__ = my_faker\n    __sync_persistence__ = SyncPersistenceHandler\n    __async_persistence__ = AsyncPersistenceHandler\n    __allow_none_optionals__ = False\n    ...\n</code></pre>"},{"location":"usage/configuration/#generating-deterministic-objects","title":"Generating deterministic objects","text":"<p>In order to generate deterministic data, use <code>ModelFactory.seed_random</code> method. This will pass the seed value to both Faker and random method calls, guaranteeing data to be the same in between the calls. Especially useful for testing.</p>"},{"location":"usage/dataclasses/","title":"Supported Models","text":"<p>This library works with any class that inherits the pydantic <code>BaseModel</code> class, including <code>GenericModel</code> and classes from 3rd party libraries, and also with dataclasses - both those from the python standard library and pydantic's dataclasses. Finally, it also supports <code>TypedDict</code> classes. In fact, you can use them interchangeably as you like:</p> <pre><code>import dataclasses\nfrom typing import Dict, List\n\nimport pydantic\n\nfrom pyfactories import ModelFactory\n\n\n@pydantic.dataclasses.dataclass\nclass MyPydanticDataClass:\n    name: str\n\n\nclass MyFirstModel(pydantic.BaseModel):\n    dataclass: MyPydanticDataClass\n\n\n@dataclasses.dataclass()\nclass MyPythonDataClass:\n    id: str\n    complex_type: Dict[str, Dict[int, List[MyFirstModel]]]\n\n\nclass MySecondModel(pydantic.BaseModel):\n    dataclasses: List[MyPythonDataClass]\n\n\nclass MyFactory(ModelFactory):\n    __model__ = MySecondModel\n\n\nresult = MyFactory.build()\n</code></pre> <p>The above example will build correctly.</p>"},{"location":"usage/dataclasses/#note-regarding-nested-optional-types-in-dataclasses","title":"Note Regarding Nested Optional Types in Dataclasses","text":"<p>When generating mock values for fields typed as <code>Optional</code>, if the factory is defined with <code>__allow_none_optionals__ = True</code>, the field value will be either a value or None - depending on a random decision. This works even when the <code>Optional</code> typing is deeply nested, except for dataclasses - typing is only shallowly evaluated for dataclasses, and as such they are always assumed to require a value. If you wish to have a None value, in this particular case, you should do so manually by configured a <code>Use</code> callback for the particular field.</p>"},{"location":"usage/defining-factory-fields/","title":"Defining Factory Fields","text":"<p>The factory api is designed to be as semantic and simple as possible, lets look at several examples that assume we have the following models:</p> <pre><code>from datetime import date, datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Union\n\nfrom pydantic import UUID4, BaseModel\n\nfrom pyfactories import ModelFactory\n\n\nclass Species(str, Enum):\n    CAT = \"Cat\"\n    DOG = \"Dog\"\n\n\nclass Pet(BaseModel):\n    name: str\n    species: Species\n\n\nclass Person(BaseModel):\n    id: UUID4\n    name: str\n    hobbies: List[str]\n    age: Union[float, int]\n    birthday: Union[datetime, date]\n    pets: List[Pet]\n    assets: List[Dict[str, Dict[str, Any]]]\n\n\npet = Pet(name=\"Roxy\", sound=\"woof woof\", species=Species.DOG)\n\n\nclass PersonFactory(ModelFactory):\n    __model__ = Person\n\n    pets = [pet]\n</code></pre> <p>In this case when we call <code>PersonFactory.build()</code> the result will be randomly generated, except the pets list, which will be the hardcoded default we defined.</p>"},{"location":"usage/defining-factory-fields/#use","title":"Use","text":"<p>This though is often not desirable. We could instead, define a factory for <code>Pet</code> where we restrict the choices to a range we like. For example:</p> <pre><code>from datetime import date, datetime\nfrom enum import Enum\nfrom random import choice\nfrom typing import Any, Dict, List, Union\n\nfrom pydantic import UUID4, BaseModel\n\nfrom pyfactories import ModelFactory, Use\n\n\nclass Species(str, Enum):\n    CAT = \"Cat\"\n    DOG = \"Dog\"\n\n\nclass Pet(BaseModel):\n    name: str\n    species: Species\n\n\nclass Person(BaseModel):\n    id: UUID4\n    name: str\n    hobbies: List[str]\n    age: Union[float, int]\n    birthday: Union[datetime, date]\n    pets: List[Pet]\n    assets: List[Dict[str, Dict[str, Any]]]\n\n\nclass PetFactory(ModelFactory):\n    __model__ = Pet\n\n    name = Use(choice, [\"Ralph\", \"Roxy\"])\n    species = Use(choice, list(Species))\n\n\nclass PersonFactory(ModelFactory):\n    __model__ = Person\n\n    pets = Use(PetFactory.batch, size=2)\n</code></pre> <p>The signature for use is: <code>cb: Callable, *args, **defaults</code>, it can receive any sync callable. In the above example, we used the <code>choice</code> function from the standard library's <code>random</code> package, and the batch method of <code>PetFactory</code>.</p> <p>You do not need to use the <code>Use</code> field, you can place callables (including classes) as values for a factory's attribute directly, and these will be invoked at build-time. Thus, you could for example re-write the above <code>PetFactory</code> like so:</p> <pre><code>from enum import Enum\nfrom random import choice\n\nfrom pydantic import BaseModel\n\nfrom pyfactories import ModelFactory\n\n\nclass Species(str, Enum):\n    CAT = \"Cat\"\n    DOG = \"Dog\"\n\n\nclass Pet(BaseModel):\n    name: str\n    species: Species\n\n\nclass PetFactory(ModelFactory):\n    __model__ = Pet\n\n    name = lambda: choice([\"Ralph\", \"Roxy\"])  # noqa: E731\n    species = lambda: choice(list(Species))  # noqa: E731\n</code></pre> <p><code>Use</code> is merely a semantic abstraction that makes the factory cleaner and simpler to understand.</p>"},{"location":"usage/defining-factory-fields/#global-factory-registration","title":"Global factory registration","text":"<p>Sometimes you want to alter how a model is built by default. It is especially useful for a model that is used a lot across the project. In this case updating attributes to reference specific factory everywhere can be quite cumbersome. Instead you can rely on auto registering models by setting the <code>__auto_register__</code> attribute`.</p> <pre><code>from datetime import date, datetime\nfrom enum import Enum\nfrom random import choice\nfrom typing import Any, Dict, List, Union\n\nfrom pydantic import UUID4, BaseModel\n\nfrom pyfactories import ModelFactory\n\n\nclass Species(str, Enum):\n    CAT = \"Cat\"\n    DOG = \"Dog\"\n\n\nclass Pet(BaseModel):\n    name: str\n    species: Species\n\n\nclass Person(BaseModel):\n    id: UUID4\n    name: str\n    hobbies: List[str]\n    age: Union[float, int]\n    birthday: Union[datetime, date]\n    pets: List[Pet]\n    assets: List[Dict[str, Dict[str, Any]]]\n\n\nclass PetFactory(ModelFactory):\n    __model__ = Pet\n    __auto_register__ = True\n\n    name = lambda: choice([\"Ralph\", \"Roxy\"])  # noqa: E731\n    species = Species.DOG\n\n\nclass PersonFactory(ModelFactory):\n    __model__ = Person\n</code></pre> <p>Here if we call <code>PersonFactory.build()</code> the result will be randomly generated except the pet list which will contain a dog with the name <code>Ralph</code> or <code>Roxy</code>. Notice that in this case we didn't have to define the <code>pets</code> attribute in the <code>PersonFactory</code> because we have registered <code>PetFactory</code> as the default factory for the <code>Pet</code> model.</p>"},{"location":"usage/defining-factory-fields/#postgenerated","title":"PostGenerated","text":"<p>It allows for post generating fields based on already generated values of other (non post generated) fields. In most cases this pattern is best avoided, but for the few valid cases the <code>PostGenerated</code> helper is provided. For example:</p> <pre><code>from datetime import datetime, timedelta\nfrom random import randint\n\nfrom pydantic import BaseModel\n\nfrom pyfactories import ModelFactory, PostGenerated\n\n\ndef add_timedelta(name: str, values: dict, *args, **kwds):\n    delta = timedelta(days=randint(0, 12), seconds=randint(13, 13000))\n    return values[\"from_dt\"] + delta\n\n\nclass MyModel(BaseModel):\n    from_dt: datetime\n    to_dt: datetime\n\n\nclass MyFactory(ModelFactory):\n    __model__ = MyModel\n\n    to_dt = PostGenerated(add_timedelta)\n</code></pre> <p>The signature for use is: <code>cb: Callable, *args, **defaults</code>, it can receive any sync callable. The signature for the callable should be: <code>name: str, values: dict[str, Any], *args, **defaults</code>. The already generated values are mapped by name in the <code>values</code> dictionary.</p>"},{"location":"usage/defining-factory-fields/#ignore","title":"Ignore","text":"<p><code>Ignore</code> is another field exported by this library, and its used - as its name implies - to designate a given attribute as ignored:</p> <pre><code>from typing import TypeVar\n\nfrom odmantic import EmbeddedModel, Model\n\nfrom pyfactories import Ignore, ModelFactory\n\nT = TypeVar(\"T\", Model, EmbeddedModel)\n\n\nclass OdmanticModelFactory(ModelFactory[T]):\n    id = Ignore()\n</code></pre> <p>The above example is basically the extension included in <code>pyfactories</code> for the library ODMantic, which is a pydantic based mongo ODM.</p> <p>For ODMantic models, the <code>id</code> attribute should not be set by the factory, but rather handled by the odmantic logic itself. Thus, the <code>id</code> field is marked as ignored.</p> <p>When you ignore an attribute using <code>Ignore</code>, it will be completely ignored by the factory - that is, it will not be set as a kwarg passed to pydantic at all.</p>"},{"location":"usage/defining-factory-fields/#require","title":"Require","text":"<p>The <code>Require</code> field in turn specifies that a particular attribute is a required kwarg. That is, if a kwarg with a value for this particular attribute is not passed when calling <code>factory.build()</code>, a <code>MissingBuildKwargError</code> will be raised.</p> <p>What is the use case for this? For example, lets say we have a document called <code>Article</code> which we store in some DB and is represented using a non-pydantic model, say, an <code>elastic-dsl</code> document. We then need to store in our pydantic object a reference to an id for this article. This value should not be some mock value, but must rather be an actual id passed to the factory. Thus, we can define this attribute as required:</p> <pre><code>from uuid import UUID\n\nfrom pydantic import BaseModel\n\nfrom pyfactories import ModelFactory, Require\n\n\nclass ArticleProxy(BaseModel):\n    article_id: UUID\n    ...\n\n\nclass ArticleProxyFactory(ModelFactory):\n    __model__ = ArticleProxy\n\n    article_id = Require()\n</code></pre> <p>If we call <code>factory.build()</code> without passing a value for article_id, an error will be raised.</p>"},{"location":"usage/defining-factory-fields/#fixture","title":"Fixture","text":"<p>The <code>Fixture</code> field is a special field meant to be used with factories that have been decorated using register_fixture. For example:</p> <pre><code>from datetime import date, datetime\nfrom typing import List, Optional, Union\n\nfrom pydantic import UUID4, BaseModel\n\nfrom pyfactories import Fixture, ModelFactory\nfrom pyfactories.plugins.pytest_plugin import register_fixture\n\n\nclass Person(BaseModel):\n    id: UUID4\n    name: str\n    hobbies: Optional[List[str]]\n    nicks: List[str]\n    age: Union[float, int]\n    birthday: Union[datetime, date]\n\n\nclass ClassRoom(BaseModel):\n    teacher: Person\n    pupils: List[Person]\n\n\n@register_fixture(name=\"my_fixture\")\nclass PersonFactory(ModelFactory):\n    __model__ = Person\n\n\nclass ClassRoomFactory(ModelFactory):\n    teacher = Fixture(PersonFactory, name=\"Jenny Osterman\")\n    pupils = Fixture(PersonFactory, size=20)\n</code></pre> <p>If we tried to use <code>PersonFactory</code> now normally it wouldn't work because pytest fixtures can only be called by pytest. Thus we can use <code>Fixture</code>. As you can see above, this field can accept kwargs that are passed to the factory's underlying build or batch methods, and an optional <code>size</code> kwarg. If <code>size</code> is given, than a batch is returned, otherwise the normal build method is used.</p>"},{"location":"usage/extensions/","title":"Extensions","text":"<p>Any class that is derived from pydantic's <code>BaseModel</code> can be used as the <code>__model__</code> of a factory. For most 3rd party libraries, e.g. SQLModel, this library will work as is out of the box.</p> <p>Currently, this library also includes the following extensions:</p>"},{"location":"usage/extensions/#odmantic","title":"ODMantic","text":"<p>This extension includes a class called <code>OdmanticModelFactory</code> and it can be imported from <code>pydantic_factory.extensions</code>. This class is meant to be used with the <code>Model</code> and <code>EmbeddedModel</code> classes exported by ODMantic, but it will also work with regular instances of pydantic's <code>BaseModel</code>.</p>"},{"location":"usage/extensions/#beanie","title":"Beanie","text":"<p>This extension includes a class called <code>BeanieDocumentFactory</code> as well as an <code>BeaniePersistenceHandler</code>. Both of these can be imported from <code>pydantic_factory.extensions</code>. The <code>BeanieDocumentFactory</code> is meant to be used with the Beanie <code>Document</code> class, and it includes async persistence build in.</p>"},{"location":"usage/extensions/#ormar","title":"Ormar","text":"<p>This extension includes a class called <code>OrmarModelFactory</code>. This class is meant to be used with the <code>Model</code> class exported by ormar.</p>"},{"location":"usage/handling-custom-types/","title":"Handling Custom Types","text":"<p>If your model has an attribute that is not supported by <code>pyfactories</code> and it depends on third party libraries, you can create your custom extension subclassing the <code>ModelFactory</code>, and overriding the <code>get_mock_value</code> method to add your logic.</p> <pre><code>from typing import Any\n\nfrom pyfactories import ModelFactory\n\n\nclass CustomFactory(ModelFactory[Any]):\n\"\"\"Tweak the ModelFactory to add our custom mocks.\"\"\"\n\n    @classmethod\n    def get_mock_value(cls, field_type: Any) -&gt; Any:\n\"\"\"Add our custom mock value.\"\"\"\n        if str(field_type) == \"my_super_rare_datetime_field\":\n            return cls.get_faker().date_time_between()\n\n        return super().get_mock_value(field_type)\n</code></pre> <p>Where <code>cls.get_faker()</code> is a <code>faker</code> instance that you can use to build your returned value.</p>"},{"location":"usage/nest-models/","title":"Nested Models","text":"<p>The automatic generation of mock data works for all types supported by pydantic, as well as nested classes that derive from <code>BaseModel</code> (including for 3rd party libraries) and complex types. Let's look at another example:</p> <pre><code>from datetime import date, datetime\nfrom enum import Enum\nfrom typing import Any, Dict, List, Union\n\nfrom pydantic import UUID4, BaseModel\n\nfrom pyfactories import ModelFactory\n\n\nclass Species(str, Enum):\n    CAT = \"Cat\"\n    DOG = \"Dog\"\n    PIG = \"Pig\"\n    MONKEY = \"Monkey\"\n\n\nclass Pet(BaseModel):\n    name: str\n    sound: str\n    species: Species\n\n\nclass Person(BaseModel):\n    id: UUID4\n    name: str\n    hobbies: List[str]\n    age: Union[float, int]\n    birthday: Union[datetime, date]\n    pets: List[Pet]\n    assets: List[Dict[str, Dict[str, Any]]]\n\n\nclass PersonFactory(ModelFactory):\n    __model__ = Person\n\n\nresult = PersonFactory.build()\n</code></pre> <p>This example will also work out of the box although no factory was defined for the Pet class, that's not a problem - a factory will be dynamically generated for it on the fly.</p> <p>The complex typing under the <code>assets</code> attribute is a bit more tricky, but the factory will generate a python object fitting this signature, therefore passing validation.</p> <p>Please note: the one thing factories cannot handle is self referencing models, because this can lead to recursion errors. In this case you will need to handle the particular field by setting defaults for it.</p>"},{"location":"usage/persistence/","title":"Persistence","text":"<p><code>ModelFactory</code> has four persistence methods:</p> <ul> <li><code>.create_sync(**kwargs)</code> - builds and persists a single instance of the factory's model synchronously</li> <li><code>.create_batch_sync(size: int, **kwargs)</code> - builds and persists a list of size n instances synchronously</li> <li><code>.create_async(**kwargs)</code> - builds and persists a single instance of the factory's model asynchronously</li> <li><code>.create_batch_async(size: int, **kwargs)</code> - builds and persists a list of size n instances asynchronously</li> </ul> <p>To use these methods, you must first specify a sync and/or async persistence handlers for the factory:</p> <pre><code>from typing import List, TypeVar\n\nfrom pydantic import BaseModel\n\nfrom pyfactories import AsyncPersistenceProtocol, ModelFactory, SyncPersistenceProtocol\n\nT = TypeVar(\"T\", bound=BaseModel)\n\n\nclass SyncPersistenceHandler(SyncPersistenceProtocol[T]):\n    def save(self, data: T) -&gt; T:\n        ...  # do stuff\n\n    def save_many(self, data: List[T]) -&gt; List[T]:\n        ...  # do stuff\n\n\nclass AsyncPersistenceHandler(AsyncPersistenceProtocol[T]):\n    async def save(self, data: T) -&gt; T:\n        ...  # do stuff\n\n    async def save_many(self, data: List[T]) -&gt; List[T]:\n        ...  # do stuff\n\n\nclass PersonFactory(ModelFactory):\n    __sync_persistence__ = SyncPersistenceHandler\n    __async_persistence__ = AsyncPersistenceHandler\n    ...\n</code></pre> <p>Or create your own base factory and reuse it in your various factories:</p> <pre><code>from typing import List, TypeVar\n\nfrom pydantic import BaseModel\n\nfrom pyfactories import AsyncPersistenceProtocol, ModelFactory, SyncPersistenceProtocol\n\nT = TypeVar(\"T\", bound=BaseModel)\n\n\nclass SyncPersistenceHandler(SyncPersistenceProtocol[T]):\n    def save(self, data: T) -&gt; T:\n        ...  # do stuff\n\n    def save_many(self, data: List[T]) -&gt; List[T]:\n        ...  # do stuff\n\n\nclass AsyncPersistenceHandler(AsyncPersistenceProtocol[T]):\n    async def save(self, data: T) -&gt; T:\n        ...  # do stuff\n\n    async def save_many(self, data: List[T]) -&gt; List[T]:\n        ...  # do stuff\n\n\nclass BaseModelFactory(ModelFactory):\n    __sync_persistence__ = SyncPersistenceHandler\n    __async_persistence__ = AsyncPersistenceHandler\n\n\nclass PersonFactory(BaseModelFactory):\n    ...\n</code></pre> <p>With the persistence handlers in place, you can now use all persistence methods. Please note - you do not need to define any or both persistence handlers. If you will only use sync or async persistence, you only need to define the respective handler to use these methods.</p>"},{"location":"usage/persistence/#create-factory-method","title":"Create Factory Method","text":"<p>If you prefer to create a factory imperatively, you can do so using the <code>ModelFactory.create_factory</code> method. This method receives the following arguments:</p> <ul> <li>model - the model for the factory.</li> <li>base - an optional base factory class. Defaults to the factory class on which the method is called.</li> <li>kwargs - a dictionary of arguments correlating to the class vars accepted by ModelFactory, e.g. faker.</li> </ul> <p>You could also override the child factory's <code>__model__</code> attribute to specify the model to use and the default kwargs as shown as the BuildPet class as shown below:</p> <pre><code>from datetime import date, datetime\nfrom enum import Enum\nfrom typing import Any, Dict, Generic, List, Optional, TypeVar, Union\n\nfrom pydantic import UUID4, BaseModel\n\nfrom pyfactories import ModelFactory\n\n\nclass Species(str, Enum):\n    CAT = \"Cat\"\n    DOG = \"Dog\"\n\n\nclass PetBase(BaseModel):\n    name: str\n    species: Species\n\n\nclass Pet(PetBase):\n    id: UUID4\n\n\nclass PetCreate(PetBase):\n    pass\n\n\nclass PetUpdate(PetBase):\n    pass\n\n\nclass PersonBase(BaseModel):\n    name: str\n    hobbies: List[str]\n    age: Union[float, int]\n    birthday: Union[datetime, date]\n    pets: List[Pet]\n    assets: List[Dict[str, Dict[str, Any]]]\n\n\nclass PersonCreate(PersonBase):\n    pass\n\n\nclass Person(PersonBase):\n    id: UUID4\n\n\nclass PersonUpdate(PersonBase):\n    pass\n\n\ndef test_factory():\n    class PersonFactory(ModelFactory):\n        __model__ = Person\n\n    person = PersonFactory.build()\n\n    assert person.pets != []\n\n\nModelType = TypeVar(\"ModelType\", bound=BaseModel)\nCreateSchemaType = TypeVar(\"CreateSchemaType\", bound=BaseModel)\nUpdateSchemaType = TypeVar(\"UpdateSchemaType\", bound=BaseModel)\n\n\nclass BUILDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):\n    def __init__(\n        self,\n        model: ModelType = None,\n        create_schema: Optional[CreateSchemaType] = None,\n        update_schema: Optional[UpdateSchemaType] = None,\n    ):\n        self.model = model\n        self.create_model = create_schema\n        self.update_model = update_schema\n\n    def build_object(self) -&gt; ModelType:\n        object_Factory = ModelFactory.create_factory(self.model)\n        return object_Factory.build()\n\n    def build_create_object(self) -&gt; CreateSchemaType:\n        object_Factory = ModelFactory.create_factory(self.create_model)\n        return object_Factory.build()\n\n    def build_update_object(self) -&gt; UpdateSchemaType:\n        object_Factory = ModelFactory.create_factory(self.update_model)\n        return object_Factory.build()\n\n\nclass BUILDPet(BUILDBase[Pet, PetCreate, PetUpdate]):\n    def build_object(self) -&gt; Pet:\n        object_Factory = ModelFactory.create_factory(self.model, name=\"Fido\")\n        return object_Factory.build()\n\n    def build_create_object(self) -&gt; PetCreate:\n        object_Factory = ModelFactory.create_factory(self.create_model, name=\"Rover\")\n        return object_Factory.build()\n\n    def build_update_object(self) -&gt; PetUpdate:\n        object_Factory = ModelFactory.create_factory(self.update_model, name=\"Spot\")\n        return object_Factory.build()\n\n\ndef test_factory_create():\n    person_factory = BUILDBase(Person, PersonCreate, PersonUpdate)\n\n    pet_factory = BUILDPet(Pet, PetCreate, PetUpdate)\n\n    create_person = person_factory.build_create_object()\n    update_person = person_factory.build_update_object()\n\n    pet = pet_factory.build_object()\n    create_pet = pet_factory.build_create_object()\n    update_pet = pet_factory.build_update_object()\n\n    assert create_person is not None\n    assert update_person is not None\n\n    assert pet.name == \"Fido\"\n    assert create_pet.name == \"Rover\"\n    assert update_pet.name == \"Spot\"\n</code></pre>"},{"location":"usage/pytest-fixtures/","title":"Using Factories as Fixtures","text":"<p>Any class from <code>ModelFactory</code> can use the decorator to register as a fixture easily.</p> <p>The model factory will be registered as a fixture with the name in snake case.</p> <p>e.g. <code>PersonFactory</code> -&gt; <code>person_factory</code></p> <p>The decorator also provides some pytest-like arguments to define the fixture. (<code>scope</code>, <code>autouse</code>, <code>name</code>)</p> <pre><code>from datetime import date, datetime\nfrom typing import List, Union\n\nfrom pydantic import UUID4, BaseModel\n\nfrom pyfactories import ModelFactory\nfrom pyfactories.plugins.pytest_plugin import register_fixture\n\n\nclass Person(BaseModel):\n    id: UUID4\n    name: str\n    hobbies: List[str]\n    age: Union[float, int]\n    birthday: Union[datetime, date]\n\n\n@register_fixture\nclass PersonFactory(ModelFactory):\n\"\"\"A person factory\"\"\"\n\n    __model__ = Person\n\n\n@register_fixture(scope=\"session\", autouse=True, name=\"cool_guy_factory\")\nclass AnotherPersonFactory(ModelFactory):\n\"\"\"A cool guy factory\"\"\"\n\n    __model__ = Person\n\n\ndef test_person_factory(person_factory: PersonFactory) -&gt; None:\n    person = person_factory.build()\n    assert isinstance(person, Person)\n\n\ndef test_cool_guy_factory(cool_guy_factory: AnotherPersonFactory) -&gt; None:\n    cool_guy = cool_guy_factory.build()\n    assert isinstance(cool_guy, Person)\n</code></pre> <p>Use <code>pytest --fixtures</code> will show output along these lines:</p> <pre><code>------------- fixtures defined from pyfactories.plugins.pytest_plugin -------------\ncool_guy_factory [session scope] -- pyfactories/plugins/pytest_plugin.py:48\n    A cool guy factory\n\nperson_factory -- pyfactories/plugins/pytest_plugin.py:48\n    A person factory\n</code></pre>"}]}
